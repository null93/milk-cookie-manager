import _ from "lodash"
import moment from "moment"
import browser from "webextension-polyfill"
import utils from "utils/cookie"
import Promise from "bluebird"
import React from "react"
import PropTypes from "prop-types"

const { Provider, Consumer } = React.createContext ()

class CookiesProvider extends React.Component {

	constructor ( props ) {
		super ( props )
		this.state = this.getDefaultState ()
	}

	componentDidMount () {
		browser.cookies.onChanged.addListener ( this.load.bind ( this ) )
		this.load ()
	}

	componentWillUnmount () {
		browser.cookies.onChanged.removeListener ( this.load.bind ( this ) )
	}

	componentDidUpdate ( prev ) {
		const termChanged = prev.search.term !== this.props.search.term
		const regexpChanged = prev.storage.data.regexp !== this.props.storage.data.regexp
		const sensitiveChanged = prev.storage.data.sensitive !== this.props.storage.data.sensitive
		const filteredChanged = prev.search.filtered !== this.props.search.filtered
		const focusChanged = prev.focus.last !== this.props.focus.last
		if ( termChanged || regexpChanged || sensitiveChanged || filteredChanged || focusChanged ) {
			this.load ()
		}
	}

	getDefaultState ( initialized = false ) {
		return {
			all: [],
			found: [],
			initialized,
		}
	}

	load () {
		const { search, storage, focus } = this.props
		const { filtered } = search
		const { last } = focus
		const params = ( last && filtered ) ? { url: last } : {}
		return browser.cookies
			.getAll ( params )
			.then ( cookies => {
				const today = moment ().unix ()
				cookies = cookies.filter ( cookie =>
					!cookie.expirationDate || cookie.expirationDate > today
				)
				this.setState ({
					all: cookies,
					found: search.filter ( cookies ),
					initialized: true,
				})
			})
			.catch ( error => {
				console.error ( "Failed to load cookies:", error )
				this.setState ( this.getDefaultState ( true ) )
			})
	}

	delete ( input ) {
		const cookies = input ? [ input ] : this.state.found
		return Promise.map ( cookies, cookie => utils.remove ( cookie ) )
	}

	block ( input ) {
		const { storage } = this.props
		const { protect } = storage.data
		const cookies = input ? [ input ] : this.state.found
		const [ keys, values ] = _.unzip ( cookies
			.filter ( cookie => !( utils.hash ( cookie ) in protect ) )
			.map ( cookie => [ utils.hash ( cookie ), cookie ] )
		)
		return storage.add ( "block", keys, values )
			.then ( () => Promise.map (
				cookies,
				cookie => utils.remove ( cookie )
			))
	}

	protect ( input ) {
		const { storage } = this.props
		const { block } = storage.data
		const cookies = input ? [ input ] : this.state.found
		const [ keys, values ] = _.unzip ( cookies
			.filter ( cookie => !( utils.hash ( cookie ) in block ) )
			.map ( cookie => [ utils.hash ( cookie ), cookie ] )
		)
		return storage.add ( "protect", keys, values )
	}

	curl () {
		const { last } = this.props.focus
		const { found } = this.state
		let url = last.replace ( /'/g, "\\'" )
		let cookies = found.map ( cookie => {
			let name = cookie.name.replace ( /"/g, '\\"' )
			let value = cookie.value.replace ( /"/g, '\\"' )
			return `${name}=${value}`
		})
		return `curl '${url}' -H "Cookie: ${cookies.join ("; ")}"`
	}

	getJson ( cookie ) {
		const { found } = this.state
		return JSON.stringify ( cookie ? cookie : found, null, "\t" )
	}

	getNetscape ( cookie ) {
		const { found } = this.state
		const items = cookie ? [ cookie ] : found
		const lines = [
			"# Netscape HTTP Cookie File",
			"# Generated by https://github.com/null93/milk-cookie-manager",
			"",
		]
		for ( let item of items ) {
			const line = [
				(!item.hostOnly && item.domain && !item.domain.startsWith (".") ? "." : "") + item.domain,
				item.hostOnly ? "TRUE" : "FALSE",
				item.path,
				item.secure ? "TRUE" : "FALSE",
				item.session || !item.expirationDate ? 0 : item.expirationDate,
				item.name,
				item.value,
			]
			lines.push ( line.join ("\t") )
		}
		return lines.join ("\n")
	}

	download ( filename = "cookies.json", contentType = "text/json", body = "" ) {
		const node = document.createElement ("a")
		const data = encodeURIComponent ( body )
		node.setAttribute ( "href", `data:${contentType};charset=utf-8,` + data )
		node.setAttribute ( "download", filename )
		node.click ()
		node.remove ()
	}

	downloadJson ( cookie ) {
		const { last } = this.props.focus
		const { filtered } = this.props.search
		const timestamp = Math.floor ( new Date ().getTime () / 1000 )
		if ( cookie ) {
			const hostname = cookie.domain.replace ( /^\./m, "" )
			this.download (
				`${cookie.name}-${hostname}-${timestamp}.json`,
				"text/json",
				this.getJson ( cookie ),
			)
		}
		else {
			const hostname = filtered && last ? new URL ( last ).hostname : "dump"
			this.download (
				`${hostname}-${timestamp}.json`,
				"text/json",
				this.getJson (),
			)
		}
	}

	downloadNetscape ( cookie ) {
		this.download (
			"cookies.txt",
			"text/plain",
			this.getNetscape ( cookie ),
		)
	}

	import ( updateCount ) {
		return new Promise ( ( resolve, reject ) => {
			const chooser = document.createElement ("input")
			chooser.type = "file"
			chooser.accept = "application/json,text/plain"
			chooser.addEventListener ( "change", () => {
				const file = chooser.files [ 0 ]
				if ( file ) {
					const reader = new FileReader ()
					reader.readAsText ( file, "UTF-8" )
					reader.onload = e => {
						try {
							const raw = e.target.result
							var data = JSON.parse ( raw )
							if ( !Array.isArray ( data ) ) data = [ data ]
							const results = {
								current: 0,
								total: data.length,
								success: [],
								expired: [],
								failed: [],
							}
							return Promise.each ( data, cookie => {
								return utils.set ( cookie )
									.then ( () => {
										results.current++
										if ( !cookie.expirationDate || cookie.expirationDate > moment ().unix () ) {
											results.success.push ( cookie )
										}
										else {
											results.expired.push ( cookie )
										}
										return updateCount ( results )
									})
									.catch ( error => {
										console.error ( error )
										results.current++
										results.failed.push ( cookie )
										return updateCount ( results )
									})
							})
							.then ( () => resolve ( results ) )
							.catch ( error => reject ( error ) )
						}
						catch ( error ) {
							// If JSON parsing fails, try Netscape format
							try {
								const raw = e.target.result
								const lines = raw.split ( "\n" )
								const data = lines
									.filter ( line => !line.startsWith ("#") && line.trim () !== "" )
									.map ( line => {
										const [ domain, hostOnly, path, secure, expirationDate, name, value ] = line.split ("\t")
										return {
											domain,
											hostOnly: hostOnly === "TRUE",
											path,
											secure: secure === "TRUE",
											expirationDate: parseFloat ( expirationDate ),
											name,
											value,
										}
									})
								const results = {
									current: 0,
									total: data.length,
									success: [],
									expired: [],
									failed: [],
								}
								return Promise.each ( data, cookie => {
									return utils.set ( cookie )
										.then ( () => {
											results.current++
											if ( !cookie.expirationDate || cookie.expirationDate > moment ().unix () ) {
												results.success.push ( cookie )
											}
											else {
												results.expired.push ( cookie )
											}
											return updateCount ( results )
										})
										.catch ( error => {
											console.error ( error )
											results.current++
											results.failed.push ( cookie )
											return updateCount ( results )
										})
								})
								.then ( () => resolve ( results ) )
								.catch ( error => reject ( error ) )
							}
							catch ( error ) {
								reject ( error )
							}
						}
					}
					reader.onerror = error => reject ( error )
				}
				else {
					reject ("Could not load selected file! Please try again.")
				}
			})
			chooser.click ()
		})
	}

	render () {
		const value = {
			all: this.state.all,
			found: this.state.found,
			initialized: this.state.initialized,
			load: this.load.bind ( this ),
			hash: utils.hash,
			getUrl: utils.url,
			delete: this.delete.bind ( this ),
			block: this.block.bind ( this ),
			protect: this.protect.bind ( this ),
			curl: this.curl.bind ( this ),
			import: this.import.bind ( this ),
			getJson: this.getJson.bind ( this ),
			getNetscape: this.getNetscape.bind ( this ),
			downloadJson: this.downloadJson.bind ( this ),
			downloadNetscape: this.downloadNetscape.bind ( this ),
			set: utils.set,
		}
		if ( process.env.NODE_ENV !== "production" ) {
			console.log ( "Cookies Provider:", value )
		}
		return <Provider value={value} >
			{this.props.children}
		</Provider>
	}

}

CookiesProvider.propTypes = {
	storage: PropTypes.object.isRequired,
	focus: PropTypes.object.isRequired,
	search: PropTypes.object.isRequired,
}

function withCookies ( Component ) {
	const name = `withCookies(${Component.displayName || Component.name})`
	const NewComponent = props => {
		const { wrappedComponentRef, ...remainingProps } = props
		return <Consumer>
		{
			value => <Component
				{...remainingProps}
				cookies={value}
				ref={wrappedComponentRef}
			/>
		}
		</Consumer>
	}
	NewComponent.displayName = name;
	NewComponent.WrappedComponent = Component
	return NewComponent
}

module.exports = {
	withCookies,
	CookiesProvider: CookiesProvider,
	CookiesConsumer: Consumer
}
